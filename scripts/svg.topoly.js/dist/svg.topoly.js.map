{"version":3,"file":"svg.topoly.js","sources":["../src/svg.topoly.js"],"sourcesContent":["import {\n  Path,\n  PathArray,\n  PointArray,\n  Polygon,\n  Polyline,\n  Number as SVGNumber,\n  extend,\n  parser\n} from '@svgdotjs/svg.js'\n\n// Normalise attributes\nconst normaliseAttributes = (attr) => {\r\n  for (var a in attr) {\n    if (!/fill|stroke|opacity|transform/.test(a)) { delete attr[a] }\n  }\r\n\r\n  return attr\r\n}\r\n\r\nconst getParserPath = (pathArray) => {\r\n  const path = parser().path\r\n  path.setAttribute('d', pathArray.toString())\r\n  return path\r\n}\r\n\r\nconst pathLength = (pathArray) => {\r\n  return getParserPath(pathArray).getTotalLength()\r\n}\r\n\r\nextend(PathArray, {\r\n  // Convert path to poly\r\n  toPoly (sample = '1%') {\r\n    let points = []\r\n    let length = 0\r\n    let x = 0\r\n    let y = 0\r\n\r\n    // parse sample value\r\n    sample = new SVGNumber(sample)\r\n\r\n    // get total length\r\n    const total = pathLength(this)\r\n\r\n    let distance\r\n\r\n    // calculate sample distance\r\n    if (sample.unit === '%') {\r\n      // sample distance in %\r\n      distance = total * sample.value\r\n    } else if (sample.unit === 'px') {\r\n      // fixed sample distance in px\r\n      distance = sample.value\r\n    } else {\r\n      // specific number of samples\r\n      distance = total / sample.value\r\n    }\r\n\r\n    // prepare arrays\r\n    const segmentsQueue = this.slice()\r\n\r\n    // prepare helpers functions\r\n    const addPoint = function (px, py) {\r\n      // get last point\r\n      const lastPoint = points[points.length - 1]\r\n\r\n      // when the last point doesn't equal the current point add the current point\r\n      if (!lastPoint || px !== lastPoint[0] || py !== lastPoint[1]) {\r\n        points.push([px, py])\r\n        x = px\r\n        y = py\r\n      }\r\n    }\r\n\r\n    const addSegmentPoint = function (segment) {\r\n      // don't bother processing path ends\r\n      if (segment[0] === 'Z') return\r\n\r\n      // map segment to x and y\r\n      switch (segment[0]) {\r\n      case 'M':\r\n      case 'L':\r\n      case 'T':\r\n        x = segment[1]\r\n        y = segment[2]\r\n        break\r\n      case 'H':\r\n        x = segment[1]\r\n        break\r\n      case 'V':\r\n        y = segment[1]\r\n        break\r\n      case 'C':\r\n        x = segment[5]\r\n        y = segment[6]\r\n        break\r\n      case 'S':\r\n      case 'Q':\r\n        x = segment[3]\r\n        y = segment[4]\r\n        break\r\n      case 'A':\r\n        x = segment[6]\r\n        y = segment[7]\r\n        break\r\n      }\r\n\r\n      // add point\r\n      addPoint(x, y)\r\n    }\r\n\r\n    let lastSegment\r\n    let segmentIndex = 0\r\n    let subPath = this.slice(0, segmentIndex + 1)\r\n    let subPathLength = pathLength(subPath)\r\n\r\n    // sample through path\r\n    while (length < total) {\r\n\r\n      // get segment index\r\n      while (subPathLength < length) {\r\n        ++segmentIndex\r\n        subPath = this.slice(0, segmentIndex + 1)\r\n        subPathLength = pathLength(subPath)\r\n      }\r\n\r\n      // get segment\r\n      const segment = this[segmentIndex]\r\n\r\n      // new segment?\r\n      if (segment !== lastSegment) {\r\n        // add the segment we just left\r\n        if (lastSegment !== undefined) {\r\n          addSegmentPoint(lastSegment)\r\n        }\r\n\r\n        // add all segments which we just skipped\r\n        while (segmentsQueue.length && segmentsQueue[0] !== segment) {\r\n          addSegmentPoint(segmentsQueue.shift())\r\n        }\r\n\r\n        lastSegment = segment\r\n      }\r\n\r\n      // add points in between when curving\r\n      switch (segment[0]) {\r\n      case 'C':\r\n      case 'T':\r\n      case 'S':\r\n      case 'Q':\r\n      case 'A':\r\n        const point = getParserPath(this).getPointAtLength(length)\r\n        addPoint(point.x, point.y)\r\n        break\r\n      }\r\n\r\n      // increment by sample value\r\n      length += distance\r\n    }\r\n\r\n    let i = 0\r\n    let il = segmentsQueue.length\r\n    // add remaining segments we didn't pass while sampling\r\n    for (; i < il; ++i) {\r\n      addSegmentPoint(segmentsQueue[i])\r\n    }\r\n\r\n    // send out as point array\r\n    return new PointArray(points)\r\n  }\r\n\r\n})\r\n\r\nextend(Path, {\r\n  // Convert path to poly\r\n  toPoly (sample = '1%', replace = true) {\r\n    // define type\r\n    const Poly = /z\\s*$/i.test(this.attr('d')) ? Polygon : Polyline\r\n\r\n    const pointArray = this.array().toPoly(sample)\r\n\r\n    // create poly\r\n    const poly = new Poly().plot(pointArray)\r\n      .attr(normaliseAttributes(this.attr()))\r\n\r\n    // insert poly\r\n    if (replace) {\r\n      this.replace(poly)\r\n    }\r\n\r\n    return poly\r\n  }\r\n\r\n})\r\n"],"names":["normaliseAttributes","attr","a","test","getParserPath","pathArray","path","parser","setAttribute","toString","pathLength","getTotalLength","extend","PathArray","toPoly","sample","points","length","x","y","SVGNumber","total","distance","unit","value","segmentsQueue","slice","addPoint","px","py","lastPoint","push","addSegmentPoint","segment","lastSegment","segmentIndex","subPath","subPathLength","undefined","shift","point","getPointAtLength","i","il","PointArray","Path","replace","Poly","Polygon","Polyline","pointArray","array","poly","plot"],"mappings":"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"}